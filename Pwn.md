================

关于路径：/usr/lib这是基本上一个标准路径的写法
pwd 指令，打印当前的路径
![[Pasted image 20260218164047.png]]
.是当级目录，..是上级目录
![[Pasted image 20260218212250.png]]
touch 创建一个文件
ls -a 显示全部的信息
rm 删除一个文件
mv 移动一个文件

find几乎可以找到任意一个文件
语法如下：
find 位置  文件名字


ls的用法：
ls -d   输出当前文件夹的名字       
ls -l    长格式，显示权限，大小，修改日期，
例：![[Pasted image 20260220105835.png]]
d表示这是目录或者是文件夹，-表示这个是文件，普通文件，-r w x表示的是这个文件的读写权限，2表示路径有两个，1个路径。目录一般是两个，文件一般只有1个
ls -c   根据文件被修改的时间排序
ls -b  将文件名中奇怪的符号表示出来，比如说空格和换行符
ls -s  是文件的物理占用空间

<font color="#938953">ln -s</font>   和      <font color="#938953">ln</font>
都是创造链接的方式，<font color="#938953">区别在于ln是硬链接，只能用于文件</font>，<font color="#c0504d">而ln -s是软连接，可以用于目录</font>。
如果用ln -s创建的相对路径，移动到其他目录下面就无法使用了，而绝对路径就还可以例子如下
                      **<font color="#c0504d">相对路径是相对于软链接的路径</font>**
![[Pasted image 20260220191941.png]]
File会告诉你文件的类型

man会告诉你命令的使用方式，是一个离线手册,space空格键向下翻页，/ 输入关键词帮你查找，n表示下一个，N是上一个，q退出，b向上翻页。
 man -k可以帮你搜索关键词，找到符合的文档
一个程序可以通过 --help来查找帮助
直接输入help +内部指令如cd 可以查看他的使用方法
## File Globbing
用*号匹配单词。可以将路径中的部分单词省略缩写，用 *,?只能省略一个字母
一般程序需要的参数，直接传入即可，不需要--和-

可以使用通配符:tab来代替*
双击两下tab可以用来查看所有以这个开头的文件或者路径

## Practicing Piping
echo hi 原本是在屏幕上打出hi，现在是echo hi>文件名(ashr)就保存在当前目录的ashr里面

其中 >是重定向符，重定向的是Standard Out(标准输出),而Standard Error一般是文件的提示信息，比方说进度到%多少啦，错误运行，一般不会被>劫持
\>\>和>的区别， >>的stdout接着之前的输入继续输入，而>一般会覆盖前面一次

2>表示标准输出的是Standard Error，>默认输出的是1>

原来所有的输入都来源于键盘，现在的输入用<重定向到文件，就像>重定向到文件是一样的。

grep 关键字 文件名    表示从文件中抓取与关键字有关的信息
如果你不想把一个程序输出的大量数据存入文件中，其实你可以使用程序运行 | grep +关键字  其中grep只抓取标准输入1里的信息，要将2的信息变成1的信息，要2>&1

<font color="#f79646">|和>的区别，>只是把数据写入内存文件，|是把数据写入内存提供给下一个程序使用</font>
<font color="#f79646">和| grep中的|完全没有区别</font>

<font color="#f79646">tee的作用：</font>：<font color="#4bacc6">将 | 管道输出一分为二，紧跟 tee 后面的一定是一个文件名 和 > 的功效是一样的，如果像输入程序的化也可以使用 >(程序名)，这样程序会西东生成一个临时文件，供tee 输入。</font>

<font color="#938953">我们用mkfifo命令来创建一个FIFO文件，当你向这个文件输入东西的时候，他会一直等你的输出，再把内容输出，否则会一直进入等待状态。</font>

## Shell Variables

<font color="#e36c09">通过echo +$+变量名可以打出变量对应的内容。</font>
<font color="#e36c09">用名称=value进行赋值。</font>

<font color="#76923c">如果你想让你的变量可以导出，加上export+变量名，表示该变量被存入环境变量里，启动该终端的子程序，始终会有该变量。</font>

<font color="#92cddc">变量=$(程序)表示将程序运行的结果以变量值的形式赋值给变量</font>

<font color="#953734">read 变量，可以将你自己输入的值读入变量，，-p可以显示提示符。read还可以将标准输入的值读入变量。read 变量名 &lt文件名，还可以将文件的内容重定向到变量里去。</font>


如果你想终止一个程序，请用kill PID number，用 ps -ef 查看
![[Pasted image 20260224133000.png]]
<font color="#4bacc6">我们可以使用crl+z去暂停程序的运行。</font>
<font color="#4bacc6">fg可以重新运行被暂停的程序。</font>
<font color="#4bacc6">bg是在后台去运行程序。</font>
<font color="#4bacc6">另外补充：ps -o 可以指定选项查看进程的状态，</font>
![[Pasted image 20260224152208.png]]

<font color="#00b050">T表示被悬挂起来，由于你的crl+z，S表示进入的睡眠模式，等待你的输入，R表示现在正处于活跃状态，+表示现在在表面运行，而不是在背后运行。</font>

<font color="#e36c09">fg不仅可以继续运行前台的程序，同样可以将后台的程序调用到前台使用。</font>
&可以在程序开始的时候就跟在后面，从而起到一开始就使程序在后台运行。
如果当你的命令错误以后，就会把错误信息写在 ?的变量里，用echo $?查看

## Untangling Users
![[Pasted image 20260224163733.png]]
这个是在/etc/shadow里的存储用户的密码（一般包含root在第一个，你的正常的在最后一个，就像在上面的一样。），和用户名。

1是用户名，2是密码，哈希加密国，分成三段：
用$分割，第一个1是用的算法，![[Pasted image 20260224164731.png]]
第二个是盐值，即使密码完全相同，这个随机的盐值也会不同。第三个是原始密码加上盐值并经行哈希算法的结果，不可逆，不可推断出。